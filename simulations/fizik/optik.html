<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raporlab ƒ∞nteraktif - Optik St√ºdyo</title>
    <style>
        :root {
            /* RAPORLAB STANDART TEMA (Aydƒ±nlƒ±k) */
            --bg-app: #f1f5f9;      
            --bg-panel: #ffffff;    
            --text-main: #0f172a;
            --text-muted: #64748b;
            
            --col-accent: #3b82f6; /* Ana Mavi */
            --col-success: #10b981; /* Ye≈üil */
            --col-danger: #ef4444; /* Kƒ±rmƒ±zƒ± */
            
            --border: #e2e8f0;
            --radius: 12px;
            --font: 'Segoe UI', system-ui, sans-serif;
        }

        body { 
            margin: 0; padding: 0; 
            background: var(--bg-app); 
            color: var(--text-main); 
            font-family: var(--font); 
            height: 100vh; 
            display: flex; 
            overflow: hidden; 
        }

        /* SOL PANEL (ARA√áLAR) */
        aside { 
            width: 300px; flex-shrink: 0;
            background: var(--bg-panel); 
            border-right: 1px solid var(--border); 
            padding: 20px; 
            display: flex; flex-direction: column; gap: 15px; 
            z-index: 20; box-shadow: 2px 0 10px rgba(0,0,0,0.03);
            overflow-y: auto;
        }

        .logo { 
            font-size: 1.4rem; font-weight: 800; color: var(--text-main); 
            letter-spacing: -0.5px; margin-bottom: 10px; 
        }
        .logo span { color: var(--col-accent); font-weight: 400; }

        /* B√∂l√ºm Ba≈ülƒ±klarƒ± */
        .section-title {
            font-size: 0.75rem; font-weight: 700; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.5px;
            margin-top: 10px; margin-bottom: 5px;
        }

        /* Ara√ß Butonlarƒ± */
        .tools-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .tool-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 5px;
            background: #f8fafc; border: 1px solid var(--border); padding: 10px;
            border-radius: var(--radius); cursor: pointer; transition: 0.2s;
            color: var(--text-main); font-weight: 600; font-size: 0.8rem;
            height: 70px;
        }
        .tool-btn:hover { background: #e0f2fe; border-color: var(--col-accent); color: var(--col-accent); }
        .tool-btn .icon { font-size: 1.5rem; }

        /* √ñzellikler Paneli */
        .properties-panel {
            background: #f8fafc; padding: 15px; border-radius: var(--radius); 
            border: 1px solid var(--border); display: none; /* Se√ßilince a√ßƒ±lƒ±r */
            animation: slideIn 0.2s ease-out;
        }
        @keyframes slideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .prop-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 0.85rem; font-weight: 600; }
        input[type="range"] { flex: 1; margin-left: 10px; accent-color: var(--col-accent); cursor: pointer; }
        
        .btn-action {
            width: 100%; padding: 8px; border-radius: 8px; border: none;
            font-weight: 700; cursor: pointer; transition: 0.2s; font-size: 0.8rem; margin-top: 5px;
        }
        .btn-delete { background: #fee2e2; color: var(--col-danger); }
        .btn-delete:hover { background: var(--col-danger); color: white; }
        
        /* Toggle Switch */
        .switch-container { display: flex; align-items: center; justify-content: space-between; font-size: 0.85rem; font-weight: 600; }
        .switch { position: relative; display: inline-block; width: 36px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #cbd5e1; transition: .3s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .3s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--col-accent); }
        input:checked + .slider:before { transform: translateX(16px); }


        /* SAƒû PANEL (CANVAS) */
        main { 
            flex: 1; position: relative; 
            background: #f1f5f9; /* A√ßƒ±k gri zemin */
            background-image: 
                linear-gradient(rgba(226, 232, 240, 0.5) 1px, transparent 1px),
                linear-gradient(90deg, rgba(226, 232, 240, 0.5) 1px, transparent 1px);
            background-size: 20px 20px; /* Grid */
            cursor: default;
        }
        canvas { display: block; width: 100%; height: 100%; }

        .top-controls {
            position: absolute; top: 15px; right: 15px; display: flex; gap: 10px;
            background: rgba(255,255,255,0.9); padding: 8px; border-radius: 12px;
            border: 1px solid var(--border); box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .tip-box {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: white; padding: 8px 16px; border-radius: 20px;
            font-weight: 600; color: var(--col-accent); pointer-events: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 1px solid var(--border); font-size: 0.9rem;
        }
    </style>
</head>
<body>

<aside>
    <div class="logo">Raporlab <span>ƒ∞nteraktif</span></div>
    
    <div class="section-title">Optik Elemanlar</div>
    <div class="tools-grid">
        <button class="tool-btn" onclick="app.addLens(150)">
            <span class="icon">üîç</span> ƒ∞nce Kenarlƒ±
        </button>
        <button class="tool-btn" onclick="app.addLens(-150)">
            <span class="icon">üëì</span> Kalƒ±n Kenarlƒ±
        </button>
        <button class="tool-btn" onclick="app.addMirror()">
            <span class="icon">ü™û</span> D√ºz Ayna
        </button>
        <button class="tool-btn" onclick="app.addBlock()">
            <span class="icon">‚¨õ</span> Engel
        </button>
    </div>

    <div class="section-title">I≈üƒ±k Kaynaƒüƒ± Ayarlarƒ±</div>
    <div class="control-box" style="background:#f8fafc; padding:10px; border-radius:12px; border:1px solid var(--border);">
        <div class="switch-container" style="margin-bottom:10px;">
            <span>Kaynak Tipi:</span>
            <div style="display:flex; gap:5px;">
                 <button id="btnSrcParallel" class="btn-action" style="width:auto; background:var(--col-accent); color:white;" onclick="app.setSourceType('parallel')">Paralel</button>
                 <button id="btnSrcPoint" class="btn-action" style="width:auto; background:#e2e8f0;" onclick="app.setSourceType('point')">Noktasal</button>
            </div>
        </div>
        <div class="prop-row">
            <span>I≈üƒ±n Sayƒ±sƒ±: <span id="valRayCount">5</span></span>
            <input type="range" id="slRayCount" min="1" max="25" step="1" value="5">
        </div>
        <div class="prop-row" id="rowSpread">
            <span>Geni≈ülik/A√ßƒ±:</span>
            <input type="range" id="slSpread" min="10" max="150" value="60">
        </div>
    </div>

    <div class="properties-panel" id="propPanel">
        <div class="section-title" style="margin-top:0; color:var(--col-accent);">Se√ßili Obje √ñzellikleri</div>
        
        <div id="propFocalGroup">
            <div class="prop-row">
                <span>Odak (f): <span id="valF" style="color:var(--col-accent)">150</span></span>
                <input type="range" id="slF" min="50" max="400" step="10">
            </div>
        </div>

        <div class="prop-row">
            <span>Boyut (h):</span>
            <input type="range" id="slH" min="40" max="250" step="10">
        </div>
        
        <div class="prop-row">
            <span>D√∂nd√ºr (¬∞):</span>
            <input type="range" id="slRot" min="-90" max="90" step="5" value="0">
        </div>

        <button class="btn-action btn-delete" onclick="app.deleteSelected()">SE√áƒ∞Lƒ∞ OBJEYƒ∞ Sƒ∞L</button>
    </div>

    <div style="margin-top:auto;">
         <button class="btn-action" style="background:#e2e8f0; color:#64748b;" onclick="app.resetScene()">SAHNEYƒ∞ TEMƒ∞ZLE</button>
    </div>
</aside>

<main id="container">
    <div class="top-controls">
         <div class="switch-container" style="gap:10px;">
            <span>Odaklarƒ± G√∂ster</span>
            <label class="switch"><input type="checkbox" checked onchange="app.toggleFocalPoints(this)"><span class="slider"></span></label>
        </div>
    </div>
    <div class="tip-box">Objeleri s√ºr√ºkleyip bƒ±rakarak optik sistemini kur!</div>
    <canvas id="simCanvas"></canvas>
</main>

<script>
const app = {
    canvas: document.getElementById('simCanvas'),
    ctx: null,
    width: 0, height: 0,

    objects: [],
    // I≈üƒ±k Kaynaƒüƒ± Ayarlarƒ±
    source: { 
        x: 50, y: 300, 
        type: 'parallel', // 'parallel' veya 'point'
        rayCount: 5, 
        spread: 60 // Paralel i√ßin geni≈ülik (px), Noktasal i√ßin a√ßƒ± (derece)
    }, 
    
    selectedObj: null,
    isDragging: false,
    dragOffset: {x:0, y:0},
    showFocals: true,
    maxBounces: 12, // I≈üƒ±n izleme derinliƒüi

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.resetScene();
        this.setupEvents();
        this.setupUIListeners();
        this.loop();
    },

    resize() {
        const el = document.getElementById('container');
        this.width = this.canvas.width = el.clientWidth;
        this.height = this.canvas.height = el.clientHeight;
        this.source.y = this.height / 2;
    },

    resetScene() {
        this.objects = [];
        // Ba≈ülangƒ±√ß: Bir ince kenarlƒ± mercek ekle
        this.objects.push({ id: 1, type: 'lens', x: this.width/2, y: this.height/2, f: 150, h: 140, rot: 0 });
        this.selectObject(null);
    },

    // --- UI VE KONTROLLER ---
    setupUIListeners() {
        // Kaynak Kontrolleri
        document.getElementById('slRayCount').oninput = (e) => {
            this.source.rayCount = parseInt(e.target.value);
            document.getElementById('valRayCount').innerText = this.source.rayCount;
        };
        document.getElementById('slSpread').oninput = (e) => {
            this.source.spread = parseInt(e.target.value);
        };

        // Obje Kontrolleri
        document.getElementById('slF').oninput = (e) => {
            if(this.selectedObj && this.selectedObj.type === 'lens') {
                const sign = Math.sign(this.selectedObj.f) || 1;
                this.selectedObj.f = parseInt(e.target.value) * sign;
                document.getElementById('valF').innerText = this.selectedObj.f;
            }
        };
        document.getElementById('slH').oninput = (e) => {
            if(this.selectedObj) this.selectedObj.h = parseInt(e.target.value);
        };
        document.getElementById('slRot').oninput = (e) => {
            if(this.selectedObj) this.selectedObj.rot = parseInt(e.target.value) * Math.PI / 180;
        };
    },

    setSourceType(type) {
        this.source.type = type;
        // Buton stillerini g√ºncelle
        const btnP = document.getElementById('btnSrcParallel');
        const btnPt = document.getElementById('btnSrcPoint');
        if(type === 'parallel') {
            btnP.style.background = 'var(--col-accent)'; btnP.style.color = 'white';
            btnPt.style.background = '#e2e8f0'; btnPt.style.color = 'black';
            document.getElementById('rowSpread').querySelector('span').innerText = "Geni≈ülik:";
             document.getElementById('slSpread').max = 200;
        } else {
            btnPt.style.background = 'var(--col-accent)'; btnPt.style.color = 'white';
            btnP.style.background = '#e2e8f0'; btnP.style.color = 'black';
            document.getElementById('rowSpread').querySelector('span').innerText = "A√ßƒ± (¬∞):";
            document.getElementById('slSpread').max = 120;
        }
    },
    toggleFocalPoints(el) { this.showFocals = el.checked; },

    // --- OBJE Y√ñNETƒ∞Mƒ∞ ---
    addLens(f) {
        this.objects.push({
            id: Date.now(), type: 'lens', 
            x: this.width/2 + (Math.random()*60-30), 
            y: this.height/2 + (Math.random()*60-30), 
            f: f, h: 120, rot: 0
        });
    },
    addMirror() {
        this.objects.push({
            id: Date.now(), type: 'mirror',
            x: this.width/2, y: this.height/2,
            f: 0, h: 100, rot: 0 
        });
    },
    addBlock() {
        this.objects.push({
            id: Date.now(), type: 'block',
            x: this.width/2, y: this.height/2,
            f: 0, h: 100, rot: 0
        });
    },
    deleteSelected() {
        if(this.selectedObj) {
            this.objects = this.objects.filter(o => o !== this.selectedObj);
            this.selectObject(null);
        }
    },

    // --- Fƒ∞Zƒ∞K MOTORU (OPTƒ∞K I≈ûIN ƒ∞ZLEME) ---
    calculateRays() {
        const rays = [];
        
        if (this.source.type === 'parallel') {
            const startY = this.source.y - this.source.spread/2;
            const step = this.source.rayCount > 1 ? this.source.spread / (this.source.rayCount - 1) : 0;
            for(let i=0; i<this.source.rayCount; i++) {
                rays.push({
                    x: this.source.x, y: startY + i*step,
                    angle: 0, // Yatay
                    path: [{x: this.source.x, y: startY + i*step}], active: true
                });
            }
        } else {
            // Noktasal Kaynak
            const startAngle = -this.source.spread / 2 * (Math.PI/180);
            const step = this.source.rayCount > 1 ? (this.source.spread * (Math.PI/180)) / (this.source.rayCount - 1) : 0;
            for(let i=0; i<this.source.rayCount; i++) {
                const angle = startAngle + i*step;
                rays.push({
                    x: this.source.x, y: this.source.y,
                    angle: angle,
                    path: [{x: this.source.x, y: this.source.y}], active: true
                });
            }
        }

        rays.forEach(ray => {
            for(let b=0; b<this.maxBounces && ray.active; b++) {
                this.traceRay(ray);
            }
            if(ray.active) {
                const last = ray.path[ray.path.length-1];
                ray.path.push({
                    x: last.x + Math.cos(ray.angle) * 3000,
                    y: last.y + Math.sin(ray.angle) * 3000
                });
            }
        });
        return rays;
    },

    traceRay(ray) {
        let closestDist = Infinity;
        let closestObj = null;
        let hitPoint = null;
        const curr = ray.path[ray.path.length-1];
        const rx = Math.cos(ray.angle); const ry = Math.sin(ray.angle);

        this.objects.forEach(obj => {
            // Obje √áizgisi Hesapla (Rotasyonlu)
            const halfH = obj.h / 2;
            const cosR = Math.cos(obj.rot); const sinR = Math.sin(obj.rot);
            const x1 = obj.x - sinR*(-halfH); const y1 = obj.y + cosR*(-halfH);
            const x2 = obj.x - sinR*(halfH);  const y2 = obj.y + cosR*(halfH);

            // √áizgi-√áizgi Kesi≈üimi
            const x3 = curr.x; const y3 = curr.y;
            const x4 = curr.x + rx*3000; const y4 = curr.y + ry*3000;

            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if(Math.abs(den) < 0.001) return;

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;

            if (t >= 0 && t <= 1 && u > 0.001) { // u > epsilon (kendi i√ßinden ge√ßmemesi i√ßin)
                const ix = x1 + t * (x2 - x1);
                const iy = y1 + t * (y2 - y1);
                const dist = u; // Ray √ºzerindeki mesafe

                if(dist < closestDist) {
                    closestDist = dist;
                    closestObj = obj;
                    hitPoint = {x: ix, y: iy};
                }
            }
        });

        if(closestObj) {
            ray.path.push(hitPoint);
            if(closestObj.type === 'block') {
                ray.active = false;
            } 
            else if (closestObj.type === 'mirror') {
                // Yansƒ±ma: Normal a√ßƒ±sƒ± = obj.rot
                ray.angle = 2 * closestObj.rot - ray.angle + Math.PI; 
            }
            else if (closestObj.type === 'lens') {
                // Kƒ±rƒ±lma (ƒ∞deal ƒ∞nce Mercek)
                // Mercek merkezinden optik eksen boyunca uzaklƒ±k (h)
                const dx = hitPoint.x - closestObj.x;
                const dy = hitPoint.y - closestObj.y;
                // Hangi tarafta olduƒüunu bulmak i√ßin lokal koordinata √ßevir
                const cos = Math.cos(-closestObj.rot);
                const sin = Math.sin(-closestObj.rot);
                const localY = dx * sin + dy * cos; // Optik eksenden sapma miktarƒ±

                // Sapma a√ßƒ±sƒ±: alpha ‚âà h / f (Radyan)
                const deflection = localY / closestObj.f; 
                ray.angle -= deflection; 
            }
        } else {
            ray.active = false;
        }
    },

    // --- √áƒ∞Zƒ∞M ---
    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.width, this.height);

        // 1. Optik Eksenler ve Odaklar (Hayalet √áizim)
        if(this.showFocals) {
            this.objects.forEach(obj => {
                if(obj.type === 'lens') this.drawFocals(obj);
            });
        }
        // Ana eksen (Paralel kaynak i√ßin)
        if(this.source.type === 'parallel') {
             ctx.strokeStyle = "#cbd5e1"; ctx.setLineDash([10,10]);
             ctx.beginPath(); ctx.moveTo(0, this.source.y); ctx.lineTo(this.width, this.source.y); ctx.stroke();
             ctx.setLineDash([]);
        }

        // 2. I≈üƒ±k Kaynaƒüƒ± Temsili
        ctx.fillStyle = "#facc15";
        if(this.source.type === 'parallel') {
             ctx.fillRect(this.source.x - 5, this.source.y - this.source.spread/2, 5, this.source.spread);
        } else {
             ctx.beginPath(); ctx.arc(this.source.x, this.source.y, 8, 0, Math.PI*2); ctx.fill();
             // I≈üƒ±k h√ºzmesi g√∂rseli
             ctx.beginPath(); ctx.moveTo(this.source.x, this.source.y);
             ctx.arc(this.source.x, this.source.y, 30, -this.source.spread/2*Math.PI/180, this.source.spread/2*Math.PI/180);
             ctx.fillStyle = "rgba(250, 204, 21, 0.2)"; ctx.fill();
        }

        // 3. Objeleri √áiz
        this.objects.forEach(obj => this.drawObject(obj));

        // 4. I≈üƒ±nlarƒ± √áiz
        const rays = this.calculateRays();
        // Parlama Efekti
        ctx.shadowBlur = 10; ctx.shadowColor = "#3b82f6"; 
        ctx.lineWidth = 2; ctx.strokeStyle = "rgba(59, 130, 246, 0.8)";
        
        rays.forEach(ray => {
            ctx.beginPath();
            if(ray.path.length > 0) {
                ctx.moveTo(ray.path[0].x, ray.path[0].y);
                for(let i=1; i<ray.path.length; i++) ctx.lineTo(ray.path[i].x, ray.path[i].y);
            }
            ctx.stroke();
        });
        ctx.shadowBlur = 0; // Efekti kapat
        
        // 5. Se√ßim Vurgusu
        if(this.selectedObj) {
            const o = this.selectedObj;
            ctx.save(); ctx.translate(o.x, o.y); ctx.rotate(o.rot);
            ctx.strokeStyle = "#3b82f6"; ctx.lineWidth = 2; ctx.setLineDash([5,5]);
            ctx.strokeRect(-20, -o.h/2 - 10, 40, o.h + 20);
            ctx.restore();
        }
    },

    drawObject(obj) {
        const ctx = this.ctx;
        ctx.save();
        ctx.translate(obj.x, obj.y);
        ctx.rotate(obj.rot);

        if(obj.type === 'lens') {
            const isConvex = obj.f > 0;
            // Lens Rengi: ƒ∞nce=Mavi, Kalƒ±n=Kƒ±rmƒ±zƒ±msƒ±
            const color = isConvex ? "#3b82f6" : "#ef4444";
            ctx.fillStyle = isConvex ? "rgba(59, 130, 246, 0.1)" : "rgba(239, 68, 68, 0.1)";
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            ctx.beginPath();
            if(isConvex) { // ()
                ctx.ellipse(0, 0, 12, obj.h/2, 0, 0, Math.PI*2);
            } else { // )(
                ctx.moveTo(-12, -obj.h/2); ctx.quadraticCurveTo(8, 0, -12, obj.h/2);
                ctx.lineTo(12, obj.h/2); ctx.quadraticCurveTo(-8, 0, 12, -obj.h/2);
                ctx.closePath();
            }
            ctx.fill(); ctx.stroke();
            // Optik merkez √ßizgisi
            ctx.beginPath(); ctx.moveTo(0, -obj.h/2); ctx.lineTo(0, obj.h/2); 
            ctx.strokeStyle = "rgba(0,0,0,0.2)"; ctx.lineWidth=1; ctx.stroke();

        } else if (obj.type === 'mirror') {
            ctx.lineWidth = 5; ctx.strokeStyle = "#64748b";
            ctx.beginPath(); ctx.moveTo(0, -obj.h/2); ctx.lineTo(0, obj.h/2); ctx.stroke();
            // Arka tarama
            ctx.lineWidth = 1;
            for(let i = -obj.h/2; i < obj.h/2; i+=8) {
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(-8, i+8); ctx.stroke();
            }
        } else if (obj.type === 'block') {
            ctx.fillStyle = "#1e293b";
            ctx.fillRect(-8, -obj.h/2, 16, obj.h);
        }
        ctx.restore();
    },

    drawFocals(obj) {
        const ctx = this.ctx;
        ctx.save();
        ctx.translate(obj.x, obj.y);
        ctx.rotate(obj.rot);
        
        const color = obj.f > 0 ? "#3b82f6" : "#ef4444";
        ctx.fillStyle = color; ctx.textAlign = "center"; ctx.font = "bold 12px sans-serif";
        
        // F1 ve F2 Noktalarƒ±
        [-obj.f, obj.f].forEach((pos, i) => {
            ctx.beginPath(); ctx.arc(pos, 0, 4, 0, Math.PI*2); ctx.fill();
            ctx.fillText(i===0 ? "F" : "F'", pos, -10);
        });
        
        // Optik Eksen √áizgisi
        ctx.strokeStyle = color; ctx.globalAlpha = 0.3; ctx.setLineDash([5,5]);
        ctx.beginPath(); ctx.moveTo(-this.width, 0); ctx.lineTo(this.width, 0); ctx.stroke();
        
        ctx.restore();
    },

    // --- ETKƒ∞LE≈ûƒ∞M EVENTS ---
    selectObject(obj) {
        this.selectedObj = obj;
        const panel = document.getElementById('propPanel');
        const fGroup = document.getElementById('propFocalGroup');

        if(obj) {
            panel.style.display = 'block';
            document.getElementById('slH').value = obj.h;
            document.getElementById('slRot').value = obj.rot * 180 / Math.PI;
            
            if(obj.type === 'lens') {
                fGroup.style.display = 'flex';
                document.getElementById('slF').value = Math.abs(obj.f);
                document.getElementById('valF').innerText = obj.f;
                document.getElementById('valF').style.color = obj.f > 0 ? "var(--col-accent)" : "var(--col-danger)";
            } else {
                fGroup.style.display = 'none';
            }
        } else {
            panel.style.display = 'none';
        }
    },

    setupEvents() {
        const getPos = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const cx = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            const cy = e.clientY || (e.touches ? e.touches[0].clientY : 0);
            return { x: cx - rect.left, y: cy - rect.top };
        };

        const start = (e) => {
            const m = getPos(e);
            let clicked = null;
            // Tersten d√∂ng√º (en √ºsttekini se√ß)
            for(let i=this.objects.length-1; i>=0; i--) {
                const o = this.objects[i];
                // Basit Hitbox (D√∂nd√ºr√ºlmemi≈ü kare varsayƒ±mƒ± - yeterli)
                const hitW = 40; const hitH = o.h + 20;
                if (Math.abs(m.x - o.x) < hitW/2 && Math.abs(m.y - o.y) < hitH/2) {
                    clicked = o; break;
                }
            }
            this.selectObject(clicked);
            if(clicked) {
                this.isDragging = true;
                this.dragOffset.x = m.x - clicked.x;
                this.dragOffset.y = m.y - clicked.y;
            }
        };
        const move = (e) => {
            if(this.isDragging && this.selectedObj) {
                const m = getPos(e);
                this.selectedObj.x = m.x - this.dragOffset.x;
                this.selectedObj.y = m.y - this.dragOffset.y;
            }
        };
        const end = () => { this.isDragging = false; };

        this.canvas.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        this.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); start(e); }, {passive:false});
        window.addEventListener('touchmove', (e) => { e.preventDefault(); move(e); }, {passive:false});
        window.addEventListener('touchend', end);
    },

    loop() {
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
};

app.init();
</script>
</body>
</html>
